<!--
  CartSync Client Script

  Mental Model:
  1. Guest Cart (Device Cart) - localStorage when not logged in
  2. Account Cart (Server Cart) - KV store when logged in
  3. Merge Logic - when guest logs in, merge device cart with account cart

  Behavior:
  - Logged out: all cart ops go to localStorage
  - Logged in: all cart ops sync to server, real-time across devices
  - On login: guest cart merges with account cart (union, last-write-wins)
  - On logout: account cart stays on server, device falls back to empty guest cart
-->




<script>
  window.CartSync = (function() {
    // ========== CONFIG ==========
    const CONFIG = {
      API_URL: 'https://composing-the-wild.webflow.io/app',
      DEBUG: true,
      GUEST_CART_KEY: 'cartsync_guest_cart',
      CUSTOMER_ID_KEY: 'cartsync_customer_id',
      VERSION_KEY: 'cartsync_version',
      SYNC_INTERVAL: 5000, // Polling interval (5 seconds)
    };
  
    // ========== STATE ==========
    const _state = {
      customerId: null,
      isLoggedIn: false,
      lastCartHash: null,
      syncing: false,
      initialized: false,
      syncInterval: null,
    };
  
    // ========== UTILS ==========
    function log(...args) {
      if (CONFIG.DEBUG) {
        console.log('%c[CartSync]', 'color: #ff6d2f; font-weight: bold', ...args);
      }
    }
  
    function now() {
      return new Date().toISOString();
    }
  
    function hashCart(items) {
      return JSON.stringify(items.map(i => `${i.merchandiseId}:${i.quantity}`).sort());
    }
  
    function cartsAreEqual(a, b) {
      if (a.length !== b.length) return false;
      const mapA = new Map(a.map(i => [i.merchandiseId, i.quantity]));
      for (const item of b) {
        if (mapA.get(item.merchandiseId) !== item.quantity) return false;
      }
      return true;
    }
  
    function computeCartDiff(browserItems, targetItems) {
      const browserMap = new Map(browserItems.map(i => [i.merchandiseId, i.quantity]));
      const targetMap  = new Map(targetItems.map(i => [i.merchandiseId, i.quantity]));
  
      const toAdd    = [];
      const toRemove = [];
      const toUpdate = [];
  
      for (const [id, qty] of targetMap) {
        const bQty = browserMap.get(id);
        if (bQty === undefined) {
          toAdd.push({ merchandiseId: id, quantity: qty });
        } else if (bQty !== qty) {
          toUpdate.push({ merchandiseId: id, quantity: qty, oldQuantity: bQty });
        }
      }
  
      for (const [id] of browserMap) {
        if (!targetMap.has(id)) {
          toRemove.push({ merchandiseId: id });
        }
      }
  
      return {
        toAdd,
        toRemove,
        toUpdate,
        hasChanges: toAdd.length > 0 || toRemove.length > 0 || toUpdate.length > 0,
      };
    }

    // ========== SAFE STORAGE HELPERS ==========
    function safeGetItem(key, defaultValue = null) {
      try {
        const value = localStorage.getItem(key);
        return value === null ? defaultValue : value;
      } catch (e) {
        log('âš ï¸ localStorage.getItem failed for key', key, e);
        return defaultValue;
      }
    }

    function safeSetItem(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
        log('âš ï¸ localStorage.setItem failed for key', key, e);
      }
    }

    function safeRemoveItem(key) {
      try {
        localStorage.removeItem(key);
      } catch (e) {
        log('âš ï¸ localStorage.removeItem failed for key', key, e);
      }
    }
  
    // ========== GUEST CART ==========
    const GuestCart = {
      get() {
        try {
          const data = safeGetItem(CONFIG.GUEST_CART_KEY);
          if (!data) return { items: [], version: 0, updatedAt: null };
          return JSON.parse(data);
        } catch {
          return { items: [], version: 0, updatedAt: null };
        }
      },
      save(cart) {
        safeSetItem(
          CONFIG.GUEST_CART_KEY,
          JSON.stringify({
            items: cart.items || [],
            version: (cart.version || 0) + 1,
            updatedAt: now(),
          }),
        );
      },
      clear() {
        safeRemoveItem(CONFIG.GUEST_CART_KEY);
        log('ðŸ—‘ï¸ Guest cart cleared');
      },
      addItem(id, quantity = 1) {
        const cart = this.get();
        const existing = cart.items.find(i => i.merchandiseId === id);
        if (existing) {
          existing.quantity += quantity;
          existing.updatedAt = now();
        } else {
          cart.items.push({ merchandiseId: id, quantity, updatedAt: now() });
        }
        this.save(cart);
        log('âž• Guest cart: added', id, 'qty:', quantity);
      },
      updateItem(id, quantity) {
        const cart = this.get();
        const existing = cart.items.find(i => i.merchandiseId === id);
        if (existing) {
          if (quantity <= 0) {
            cart.items = cart.items.filter(i => i.merchandiseId !== id);
          } else {
            existing.quantity = quantity;
            existing.updatedAt = now();
          }
          this.save(cart);
        }
        log('âœï¸ Guest cart: updated', id, 'to qty:', quantity);
      },
      removeItem(id) {
        const cart = this.get();
        cart.items = cart.items.filter(i => i.merchandiseId !== id);
        this.save(cart);
        log('âž– Guest cart: removed', id);
      },
      hasItems() {
        return this.get().items.length > 0;
      },
    };
  
    // ========== SERVER CART API ==========
    const ServerCart = {
      async fetch(customerId) {
        try {
          const res = await fetch(`${CONFIG.API_URL}/api/cart`, {
            headers: { 'x-customer-id-master-zero': customerId },
          });
          if (!res.ok) return null;
          return await res.json();
        } catch (e) {
          log('âŒ Server fetch error:', e);
          return null;
        }
      },
      async sync(customerId, items, version = 0, options = {}) {
        try {
          const res = await fetch(`${CONFIG.API_URL}/api/cart/sync`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-customer-id-master-zero': customerId,
            },
            body: JSON.stringify({ items, version, ...options }),
          });
          if (!res.ok) {
            log('âŒ Server sync error:', res.status);
            return null;
          }
          const data = await res.json();
          if (data.cart?.version) {
            safeSetItem(CONFIG.VERSION_KEY, String(data.cart.version));
          }
          return data;
        } catch (e) {
          log('âŒ Server sync error:', e);
          return null;
        }
      },
      async mergeGuestCart(customerId, guestCart) {
        return this.sync(customerId, [], 0, {
          isLoginMerge: true,
          guestCart: { items: guestCart.items },
        });
      },
    };
  
    // ========== MERGE LOGIC (used only on login) ==========
    function mergeItems(localItems, serverItems) {
      const map = new Map();
      for (const item of serverItems || []) {
        map.set(item.merchandiseId, { ...item });
      }
      for (const item of localItems || []) {
        const existing = map.get(item.merchandiseId);
        if (!existing) {
          map.set(item.merchandiseId, { ...item });
        } else {
          const localTime = new Date(item.updatedAt || 0).getTime();
          const serverTime = new Date(existing.updatedAt || 0).getTime();
          if (localTime > serverTime) {
            map.set(item.merchandiseId, { ...item });
          }
        }
      }
      return Array.from(map.values()).filter(it => it.quantity > 0);
    }
  
    // ========== SMOOTIFY INTEGRATION ==========
    const Smootify = {
      async isReady() {
        let attempts = 0;
        while (!window.Smootify?.getCart && attempts < 100) {
          await new Promise(r => setTimeout(r, 100));
          attempts++;
        }
        return !!window.Smootify?.getCart;
      },
      async getCart() {
        try {
          return await window.Smootify.getCart();
        } catch {
          return null;
        }
      },
      async getCustomerId() {
        try {
          const cart = await this.getCart();
          if (cart?.buyerIdentity?.customer?.id) {
            return cart.buyerIdentity.customer.id;
          }
        } catch {}
        try {
          if (window.Smootify?.queryCustomer) {
            const resp = await window.Smootify.queryCustomer('id');
            const customer = resp?.customer || resp?.data?.customer || resp;
            if (customer?.id) return customer.id;
          }
        } catch {}
        return null;
      },
      formatCartItems(cart) {
        if (!cart?.lines?.nodes) return [];
        return cart.lines.nodes
          .filter(n => n.merchandise?.id)
          .map(n => ({
            merchandiseId: n.merchandise.id,
            quantity: n.quantity,
            // Don't send fake timestamps - let server track actual change times
          }));
      },
      async clearCart() {
        try {
          await window.Smootify.clearCart();
        } catch (e) {
          log('Clear cart error:', e);
        }
      },
      async addItems(items) {
        for (const item of items) {
          try {
            await window.Smootify.addToCart([
              { merchandiseId: item.merchandiseId, quantity: item.quantity },
            ]);
          } catch (e) {
            log('Add item error:', e);
          }
        }
      },
      async removeItem(id) {
        try {
          const cart = await this.getCart();
          const line = cart?.lines?.nodes?.find(n => n.merchandise?.id === id);
          if (line?.id && window.Smootify.removeFromCart) {
            await window.Smootify.removeFromCart([line.id]);
          }
        } catch (e) {
          log('Remove item error:', e);
        }
      },
      async updateItemQuantity(id, qty) {
        try {
          const cart = await this.getCart();
          const line = cart?.lines?.nodes?.find(n => n.merchandise?.id === id);
          if (line?.id && window.Smootify.updateCart) {
            await window.Smootify.updateCart([{ id: line.id, quantity: qty }]);
          }
        } catch (e) {
          log('Update quantity error:', e);
        }
      },
      async applyDiff(diff) {
        // Get fresh cart once to avoid stale data
        const cart = await this.getCart();
        if (!cart) return;
        
        const lineMap = new Map();
        for (const line of cart.lines?.nodes || []) {
          if (line.merchandise?.id) {
            lineMap.set(line.merchandise.id, line);
          }
        }
        
        // Remove items first
        for (const item of diff.toRemove) {
          const line = lineMap.get(item.merchandiseId);
          if (line?.id && window.Smootify.removeFromCart) {
            try {
              await window.Smootify.removeFromCart([line.id]);
            } catch (e) {
              log('Remove item error:', e);
            }
          }
        }
        
        // Small delay to let removals propagate
        if (diff.toRemove.length > 0) {
          await new Promise(r => setTimeout(r, 200));
        }
        
        // Update quantities
        for (const item of diff.toUpdate) {
          const line = lineMap.get(item.merchandiseId);
          if (line?.id && window.Smootify.updateCart) {
            try {
              await window.Smootify.updateCart([{ id: line.id, quantity: item.quantity }]);
            } catch (e) {
              log('Update quantity error:', e);
            }
          }
        }
        
        // Add new items
        for (const item of diff.toAdd) {
          try {
            await window.Smootify.addToCart([
              { merchandiseId: item.merchandiseId, quantity: item.quantity },
            ]);
          } catch (e) {
            log('Add item error:', e);
          }
        }
      },
    };
  
    // ========== AUTH & SYNC ==========
    async function checkAuthState() {
      const freshId = await Smootify.getCustomerId();
      const storedId = safeGetItem(CONFIG.CUSTOMER_ID_KEY);
      log('Auth check - Fresh:', freshId, '| Stored:', storedId);
  
      if (!freshId) {
        if (storedId) {
          log('ðŸ‘‹ User logged out');
          safeRemoveItem(CONFIG.CUSTOMER_ID_KEY);
          safeRemoveItem(CONFIG.VERSION_KEY);
        }
        _state.isLoggedIn = false;
        _state.customerId = null;
        return { isLoggedIn: false, customerId: null };
      }
  
      _state.customerId = freshId;
      _state.isLoggedIn = true;
  
      if (storedId === freshId) {
        return { isLoggedIn: true, customerId: freshId, changed: false };
      }
  
      if (storedId && storedId !== freshId) {
        log('ðŸ”„ Customer changed from', storedId, 'to', freshId);
      } else {
        log('ðŸ” User logged in:', freshId);
      }
  
      safeSetItem(CONFIG.CUSTOMER_ID_KEY, freshId);
      safeRemoveItem(CONFIG.VERSION_KEY);
  
      const guestCart = GuestCart.get();
      if (guestCart.items.length > 0) {
        log('ðŸ“¦ Guest cart has items - will merge on sync');
        return { isLoggedIn: true, customerId: freshId, needsMerge: true, guestCart };
      }
  
      return { isLoggedIn: true, customerId: freshId, changed: true };
    }
  
    async function initialSync() {
      const authState = await checkAuthState();
  
      if (!authState.isLoggedIn) {
        const guestCart = GuestCart.get();
        if (guestCart.items.length > 0) {
          log('ðŸ“¦ Guest cart has', guestCart.items.length, 'items');
          // Restore guest cart to Smootify UI so user can see it
          const browserCart = await Smootify.getCart();
          const browserItems = Smootify.formatCartItems(browserCart);
          const guestItems = guestCart.items.map(i => ({
            merchandiseId: i.merchandiseId,
            quantity: i.quantity,
          }));
          
          // Only add items that aren't already in browser cart
          const browserIds = new Set(browserItems.map(i => i.merchandiseId));
          const toAdd = guestItems.filter(i => !browserIds.has(i.merchandiseId));
          
          if (toAdd.length > 0) {
            log('â†’ Restoring', toAdd.length, 'guest cart items to UI');
            await Smootify.addItems(toAdd);
          }
        }
        return;
      }
  
      log('âœ… Logged in as:', authState.customerId);
  
      if (authState.needsMerge && authState.guestCart) {
        log('ðŸ”€ Merging guest cart with account cartâ€¦');
        const result = await ServerCart.mergeGuestCart(authState.customerId, authState.guestCart);
        if (result?.cart) {
          log('âœ… Merge complete -', result.cart.items.length, 'items');
          GuestCart.clear();
          const browserCart = await Smootify.getCart();
          const browserItems = Smootify.formatCartItems(browserCart);
          const diff = computeCartDiff(browserItems, result.cart.items);
          if (diff.hasChanges) {
            log('â†’ Applying merge diff:', diff.toAdd.length, 'add,', diff.toRemove.length, 'remove,', diff.toUpdate.length, 'update');
            await Smootify.applyDiff(diff);
            // Small delay to let Smootify propagate changes
            await new Promise(r => setTimeout(r, 300));
          }
          _state.lastCartHash = hashCart(result.cart.items);
        }
        return;
      }
  
      const serverCart  = await ServerCart.fetch(authState.customerId);
      const browserCart = await Smootify.getCart();
      const serverItems  = serverCart?.items || [];
      const browserItems = Smootify.formatCartItems(browserCart);
  
      log('Server:', serverItems.length, 'items | Browser:', browserItems.length, 'items');
  
      if (!serverItems.length && !browserItems.length) {
        log('Both carts empty');
        return;
      }
  
      if (!serverItems.length && browserItems.length) {
        log('â†’ Server empty - syncing browser cart to server');
        await ServerCart.sync(authState.customerId, browserItems, 0);
        _state.lastCartHash = hashCart(browserItems);
        return;
      }
  
      if (!browserItems.length && serverItems.length) {
        log('â†’ Restoring cart from server');
        await Smootify.addItems(serverItems);
        _state.lastCartHash = hashCart(serverItems);
        return;
      }
  
      if (!cartsAreEqual(browserItems, serverItems)) {
        log('â†’ Server is authoritative - syncing browser to server state');
        const diff = computeCartDiff(browserItems, serverItems);
        if (diff.hasChanges) {
          log('â†’ Applying diff:', diff.toAdd.length, 'add,', diff.toRemove.length, 'remove,', diff.toUpdate.length, 'update');
          await Smootify.applyDiff(diff);
          // Small delay to let Smootify propagate changes
          await new Promise(r => setTimeout(r, 300));
        }
        _state.lastCartHash = hashCart(serverItems);
      } else {
        log('âœ“ Carts already in sync');
        _state.lastCartHash = hashCart(browserItems);
      }
    }
  
    async function syncCurrentCart() {
      if (_state.syncing) return;
      _state.syncing = true;
      try {
        const authState = await checkAuthState();
        if (!authState.isLoggedIn) return;

        if (authState.needsMerge && authState.guestCart) {
          await initialSync();
          return;
        }

        const cart = await Smootify.getCart();
        if (!cart) return;

        const items = Smootify.formatCartItems(cart);
        const hash  = hashCart(items);
        if (hash === _state.lastCartHash) return;

        // Don't update hash yet - wait for successful sync
        const version = parseInt(safeGetItem(CONFIG.VERSION_KEY, '0') || '0', 10);
        log('ðŸ“¤ Syncing', items.length, 'items to server');

        const result = await ServerCart.sync(authState.customerId, items, version);

        if (!result) {
          log('âš ï¸ Sync failed - will retry on next poll');
          return; // Don't update hash, will retry
        }

        // Update hash only after successful sync
        _state.lastCartHash = hash;

        if (result.conflict) {
          log('âš ï¸ Conflict detected - applying merged cart');
          // Small delay to let any pending cart operations complete
          await new Promise(r => setTimeout(r, 300));
          const currentCart  = await Smootify.getCart();
          const currentItems = Smootify.formatCartItems(currentCart);
          const diff = computeCartDiff(currentItems, result.cart.items);
          if (diff.hasChanges) {
            log('â†’ Applying conflict diff:', diff.toAdd.length, 'add,', diff.toRemove.length, 'remove,', diff.toUpdate.length, 'update');
            await Smootify.applyDiff(diff);
            // Update hash to merged result
            _state.lastCartHash = hashCart(result.cart.items);
          } else {
            // No diff needed, just update hash
            _state.lastCartHash = hashCart(result.cart.items);
          }
        }
      } finally {
        _state.syncing = false;
      }
    }
  
    // ========== PUBLIC API ==========
    const publicAPI = {
      setApiUrl(url) {
        CONFIG.API_URL = url;
      },
      setDebug(enabled) {
        CONFIG.DEBUG = enabled;
      },
      addToCart(id, qty = 1) {
        if (_state.isLoggedIn) {
          log('âž• Add to cart (logged in):', id);
          return;
        }
        GuestCart.addItem(id, qty);
      },
      updateCartItem(id, qty) {
        if (_state.isLoggedIn) {
          log('âœï¸ Update cart item (logged in):', id, qty);
          return;
        }
        GuestCart.updateItem(id, qty);
      },
      removeFromCart(id) {
        if (_state.isLoggedIn) {
          log('âž– Remove from cart (logged in):', id);
          return;
        }
        GuestCart.removeItem(id);
      },
      async getCart() {
        if (_state.isLoggedIn && _state.customerId) {
          const serverCart = await ServerCart.fetch(_state.customerId);
          return serverCart?.items || [];
        }
        return GuestCart.get().items;
      },
      async sync() {
        await syncCurrentCart();
      },
      async refresh() {
        await initialSync();
      },
      getState() {
        return {
          isLoggedIn: _state.isLoggedIn,
          customerId: _state.customerId,
          hasGuestCart: GuestCart.hasItems(),
        };
      },
      clearAllData() {
        GuestCart.clear();
        safeRemoveItem(CONFIG.CUSTOMER_ID_KEY);
        safeRemoveItem(CONFIG.VERSION_KEY);
        _state.lastCartHash = null;
        log('ðŸ—‘ï¸ All CartSync data cleared');
      },
      async init() {
        if (_state.initialized) return;
        _state.initialized = true;
        
        // Cleanup any existing interval (in case of re-init)
        if (_state.syncInterval) {
          clearInterval(_state.syncInterval);
        }
        
        log('ðŸš€ Initializingâ€¦');
        const ready = await Smootify.isReady();
        if (!ready) {
          log('âš ï¸ Smootify not found - running in standalone mode');
        } else {
          log('âœ… Smootify ready');
          await new Promise(r => setTimeout(r, 2000));
        }
        await initialSync();
        _state.syncInterval = setInterval(() => syncCurrentCart(), CONFIG.SYNC_INTERVAL);
        log('âœ… CartSync initialized');
      },
      
      destroy() {
        if (_state.syncInterval) {
          clearInterval(_state.syncInterval);
          _state.syncInterval = null;
        }
        _state.initialized = false;
        _state.syncing = false;
        log('ðŸ›‘ CartSync destroyed');
      },
    };
  
    return publicAPI;
  })();
  
  // Autoâ€‘init
  CartSync.init();
  </script>
  